#include <stdlib.h>        #include <fstream>#include <iostream>#include "fileIO_PPM.h"using namespace std;bool getHeaderInfoPPM(FILE *inPPM, char *fileName, int *nbRows, int *nbCols, int *maxVal);							//----------------------------------------------------------------------//	readPPM()//	Goal :	read a 24-bit color image in PPM format (binary or ASCII)//	Input:	the image to read//			the input file name.////	Rant://		PPM (and its PBM/PGM brethens) is just about the stupidest image//		file format out there.  Only a Unix programmer could possibly have//		come up with something that dumb.  It is dumb because it mixes//		binary and ASCII stuff, and obliges you to work around the \r chars//		(if you are working on any other platform other than Unix, there *will* //		be \r characters), while Unix-centric stdio functions don't handle that//		character as an end of string.  Of course, all the code written by Unix//		geeks to read PPM will fail miserably if you try to run it on Windows//		or on a Mac because they simply ignore \r.//	//	Note: The function readPPM_ allows to specify if images should be//			read upside-down//----------------------------------------------------------------------unsigned char *readPPM(char *fileName, int *nbRows, int *nbCols, eImageFileType *theType){	return readPPM_(fileName, false, nbRows, nbCols, theType);}//unsigned char *readPPM_(char *fileName, bool upsideDown, int *nbRows, int *nbCols,							eImageFileType *theType){	char			sBuf[80], *buf;	int				i, j, index,					maxVal;	float			valScale;	bool			isASCII = false;	FILE			*inPPM;	int				theRed, theGreen, theBlue;	unsigned char	*pixelData;	char			cRed, cGreen, cBlue;	//	reset dimensions (just to play it safe)	*nbCols = 0;	*nbRows = 0;		// --- open file ---	inPPM = fopen(fileName, "r");	if (inPPM == NULL)	{		cout << "File " << fileName << " not found." << endl;		std::exit(kFileNotFound);    }	isASCII = getHeaderInfoPPM(inPPM, fileName, nbRows, nbCols, &maxVal);		//	Allocate the pixel array	pixelData = new unsigned char [3*(*nbCols)*(*nbRows)];	//	We only want to handle values in the [0, 255] range	if (maxVal != 255)		valScale = 255./maxVal;	//	The image is stored in an ASCII format	if (isASCII)	{		if (upsideDown)		{			for (i = (*nbRows)-1; i >= 0; i--)			{				index = 3*i*(*nbCols);								for (j = 0; j < (*nbCols); j++)				{					fscanf(inPPM, "%d%d%d", &theRed, &theGreen, &theBlue);					if (maxVal == 255)					{						pixelData[index++] = (unsigned char) theRed;						pixelData[index++] = (unsigned char) theGreen;						pixelData[index++] = (unsigned char) theBlue;					}					else					{						pixelData[index++] = (unsigned char) (valScale*theRed);						pixelData[index++] = (unsigned char) (valScale*theGreen);						pixelData[index++] = (unsigned char) (valScale*theBlue);					}				}			}		}		//	the image is not read upside down		else		{			index = 0;						for (i = 0; i < *nbRows; i++)				for (j = 0; j < (*nbCols); j++)				{					fscanf(inPPM, "%d%d%d", &theRed, &theGreen, &theBlue);					if (maxVal == 255)					{						pixelData[index++] = (unsigned char) theRed;						pixelData[index++] = (unsigned char) theGreen;						pixelData[index++] = (unsigned char) theBlue;					}					else					{						pixelData[index++] = (unsigned char) (valScale*theRed);						pixelData[index++] = (unsigned char) (valScale*theGreen);						pixelData[index++] = (unsigned char) (valScale*theBlue);					}				}		}	}	//	The image is stored in a binary format	else		{		if (upsideDown)		{			for (i = (*nbRows)-1; i >= 0; i--)			{				index = 3*i*(*nbCols);								for (j = 0; j < (*nbCols); j++)				{					fscanf(inPPM, "%c%c%c", &cRed, &cGreen, &cBlue);					//	for binary format I don't bother about the scaling 						pixelData[index++] = (unsigned char) cRed;						pixelData[index++] = (unsigned char) cGreen;						pixelData[index++] = (unsigned char) cBlue;				}			}		}		//	the image is not read upside down		else		{			index = 0;						for (i = 0; i < *nbRows; i++)				for (j = 0; j < (*nbCols); j++)				{					fscanf(inPPM, "%c%c%c", &cRed, &cGreen, &cBlue);					//	for binary format I don't bother about the scaling 						pixelData[index++] = (unsigned char) cRed;						pixelData[index++] = (unsigned char) cGreen;						pixelData[index++] = (unsigned char) cBlue;				}		}	}	fclose(inPPM);	*theType = kPPM;	return pixelData;}//----------------------------------------------------------------------//	writePPM()//	Goal :	read a 24-bit color image in PPM format (binary or ASCII)//	Input:	the image to read//			the input file name.////	Returns: Error code (0 = no error)////	Note: The function writePPM_ allows to specify if images should be//			written upside-down//----------------------------------------------------------------------eFileErrorCode writePPM(char *fileName, unsigned char *image, int nbRows, int nbCols){	return writePPM_(fileName, image, nbRows, nbCols, false);}eFileErrorCode writePPM_(char *fileName, unsigned char *image, int nbRows, int nbCols,							bool upsideDown){	FILE* fp;	int   ierr;	if (fileName == NULL)	{		printf("Error in writePPM: file name == NULL\n");		return kFileNameNull;	}	fp = fopen(fileName, "wb");	if (fp == NULL)	{		printf("Error in writePPM: couldn't write to file %s\n", fileName);		return kCannotOpenWrite;	}	fprintf(fp, "P6\n");	fprintf(fp, "%d %d\n", nbCols, nbRows);	fprintf(fp, "255\n");	if (!upsideDown)	{		ierr = fwrite(image, 1, 3 * nbRows * nbCols, fp);		if (ierr != 3 * nbRows * nbCols)		{			printf("Error in writePPM: Couldn't write %d bytes to file %s\n", 						nbRows * nbCols, fileName);			fclose(fp);			return kErrorWriting;		}	}	else		for (int i=nbRows-1; i>=0; i--)		{			ierr = fwrite(image+3*i*nbCols, 1, 3*nbCols, fp);			if (ierr != 3*nbCols) 			{				fprintf(stderr, "Error in writePPM: couldn't write %d bytes to file %s\n",									nbRows * nbCols, fileName);				fclose(fp);				return kErrorWriting;			}					}			fclose(fp);	return kNoIOerror;}bool getHeaderInfoPPM(FILE *inPPM, char *fileName, int *nbRows, int *nbCols, int *maxVal){	char	buf[80], skip[80], imgCode[2], c;	int		k;	bool	commentsSkipped = false;		// --- find if we have a known picture format ---	fscanf(inPPM, "%s", buf);	imgCode[0] = buf[0];	imgCode[1] = buf[1];		if ((imgCode[0] != 'P') || ((imgCode[1] != '3') && (imgCode[1] != '6')) )	{		cout << fileName << " not a file in the PPM format." << endl;		std::exit(kWrongFileType);	}		//	Note: I am doing some really ugly stuff with file input and buffers.	//	I am not sure if I had to do that because ANSI file I/O libraries	//	on the Mac are screwed up (they might be, for all I know), or just	//	because I kept missing something important somewhere.	//	skip whitespace	fscanf(inPPM, "%[\n\r\t ]", skip);	//	read until we encounter a non-whitespace character.  This could be a $#@# comment	//	or the nb of columns	fscanf(inPPM, "%[^\n\r\t ]", buf);		if (buf[0] != '#')		commentsSkipped = true;			while (!commentsSkipped)	{		//	if we stepped into  some comment...		if (buf[0] == '#')		{			//	...skip the rest of the line			fscanf(inPPM, "%[^\n\r]", skip);			//	skip additional whitespace on the next line			fscanf(inPPM, "%[\n\r\t ]", skip);						//	then read until the next whitespace			fscanf(inPPM, "%[^\n\r\t ]", buf);		}		else			commentsSkipped = true;	}		//	buf should contain only one thing: the width of the image	sscanf(buf,"%d", nbCols);		//	the rest of the info is read from the file stream	fscanf(inPPM,"%d", nbRows);	fscanf(inPPM,"%d", maxVal);					//	Read the extra space	fscanf(inPPM, "%c", &c);		if (imgCode[1] == '3')		return true;	else		return false;	}